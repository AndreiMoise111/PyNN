====================
PyNN API version 0.6
====================


----

Simulation setup and control
============================

setup(timestep=0.1, min_delay=0.1, max_delay=10.0, **extra_params)
------------------------------------------------------------------


Should be called at the very beginning of a script.
extra_params contains any keyword arguments that are required by a given
simulator but not by others.



end(compatible_output=True)
---------------------------

Do any necessary cleaning up before exiting.



run(simtime)
-------------

Run the simulation for simtime ms.



reset()
-------

Reset the time to zero, neuron membrane potentials and synaptic weights to
their initial values, and delete any recorded data. The network structure is
not changed, nor is the specification of which neurons to record from.



get_time_step()
---------------

Return the integration time step.



get_current_time()
------------------

Return the current time in the simulation.



get_min_delay()
---------------

Return the minimum allowed synaptic delay.



get_max_delay()
---------------

Return the maximum allowed synaptic delay.



rank()
------

Return the MPI rank of the current node.



num_processes()
---------------

Return the number of MPI processes.


----



----

Procedural interface for creating, connecting and recording networks
====================================================================

create(cellclass, cellparams=None, n=1)
---------------------------------------

Create n cells all of the same type.

If n > 1, return a list of cell ids/references.

If n==1, return just the single id.



connect(source, target, weight=None, delay=None, synapse_type=None, p=1, rng=None)
----------------------------------------------------------------------------------

Connect a source of spikes to a synaptic target.

source and target can both be individual cells or lists of cells, in which
case all possible connections are made with probability p, using either the
random number generator supplied, or the default rng otherwise.
Weights should be in nA or ÂµS.



set(cells, param, val=None)
---------------------------

Set one or more parameters of an individual cell or list of cells.

param can be a dict, in which case val should not be supplied, or a string
giving the parameter name, in which case val is the parameter value.



record(source, filename)
------------------------

Record spikes to a file. source can be an individual cell or a list of
cells.



record(source, filename)
------------------------

Record membrane potential to a file. source can be an individual cell or
a list of cells.



record(source, filename)
------------------------

Record synaptic conductances to a file. source can be an individual cell
or a list of cells.


----



----

Object-oriented interface for creating, connecting and recording networks
=========================================================================

----

Population
----------

An array of neurons all of the same type. `Population' is used as a generic
term intended to include layers, columns, nuclei, etc., of cells.

**__getitem__(self, addr)**

Return a representation of the cell with coordinates given by addr,
suitable for being passed to other methods that require a cell id.
Note that !__getitem!__ is called when using [] access, e.g.

    p = Population(...)

    p[2,3] is equivalent to p.!__getitem!__((2,3)).

Also accepts slices, e.g.

    p[0,3:6]

which returns an array of cells.


**__init__(self, dims, cellclass, cellparams=None, label=None)**

Create a population of neurons all of the same type.

dims should be a tuple containing the population dimensions, or a single
  integer, for a one-dimensional population.
  e.g., (10,10) will create a two-dimensional population of size 10x10.

cellclass should either be a standardized cell class (a class inheriting
from common.!StandardCellType) or a string giving the name of the
simulator-specific model that makes up the population.
cellparams should be a dict which is passed to the neuron model constructor
label is an optional name for the population.


**__iter__(self)**

Iterator over cell ids on the local node.


**__len__(self)**

Return the total number of cells in the population.


**addresses(self)**

Iterator over cell addresses on the local node.


**all(self)**

Iterator over cell ids on all nodes.


**can_record(self, variable)**

Determine whether `variable` can be recorded from this population.


**describe(self, template='standard', fill=<function <lambda> at 0x2854470>)**

Returns a human-readable description of the population


**get(self, parameter_name, as_array=False)**

Get the values of a parameter for every cell in the population.


**getSpikes(self, gather=True, compatible_output=True)**

Return a 2-column numpy array containing cell ids and spike times for
recorded cells.
Useful for small populations, for example for single neuron Monte-Carlo.



**get_gsyn(self, gather=True, compatible_output=True)**

Return a 3-column numpy array containing cell ids and synaptic
conductances for recorded cells.


*get_spike_counts(self, gather=True)**

Returns the number of spikes for each neuron.


**get_v(self, gather=True, compatible_output=True)**

Return a 2-column numpy array containing cell ids and Vm for
recorded cells.


**id_to_index(self, id)**

Given the ID of a cell in the Population, return its index (order in the
Population).
>>> assert id_to_index(p.index(5)) == 5


**ids(self)**

Iterator over cell ids on the local node.


**index(self, n)**

Return the nth cell in the population (Indexing starts at 0).
n may be a list or array, e.g., [i,j,k], in which case, returns the
ith, jth and kth cells in the population.


**inject(self, current_source)**

Connect a current source to all cells in the Population.


**locate(self, id)**

Given an element id in a Population, return the coordinates.

    e.g. for  4 6  , element 2 has coordinates (1,0) and value 7
              7 9


**meanSpikeCount(self, gather=True)**

Returns the mean number of spikes per neuron.


**nearest(self, position)**

Return the neuron closest to the specified position.


**printSpikes(self, file, gather=True, compatible_output=True)**

Write spike times to file.

file should be either a filename or a PyNN File object.

If compatible_output is True, the format is "spiketime cell_id",
where cell_id is the index of the cell counting along rows and down
columns (and the extension of that for 3-D).
This allows easy plotting of a `raster' plot of spiketimes, with one
line for each cell.
The timestep, first id, last id, and number of data points per cell are
written in a header, indicated by a '#' at the beginning of the line.

If compatible_output is False, the raw format produced by the simulator
is used. This may be faster, since it avoids any post-processing of the
spike files.

For parallel simulators, if gather is True, all data will be gathered
to the master node and a single output file created there. Otherwise, a
file will be written on each node, containing only the cells simulated
on that node.


**print_gsyn(self, file, gather=True, compatible_output=True)**

Write synaptic conductance traces to file.

file should be either a filename or a PyNN File object.

If compatible_output is True, the format is "t g cell_id",
where cell_id is the index of the cell counting along rows and down
columns (and the extension of that for 3-D).
The timestep, first id, last id, and number of data points per cell are
written in a header, indicated by a '#' at the beginning of the line.
If compatible_output is False, the raw format produced by the simulator
is used. This may be faster, since it avoids any post-processing of the
voltage files.


**print_v(self, file, gather=True, compatible_output=True)**

Write membrane potential traces to file.

file should be either a filename or a PyNN File object.

If compatible_output is True, the format is "v cell_id",
where cell_id is the index of the cell counting along rows and down
columns (and the extension of that for 3-D).
The timestep, first id, last id, and number of data points per cell are
written in a header, indicated by a '#' at the beginning of the line.

If compatible_output is False, the raw format produced by the simulator
is used. This may be faster, since it avoids any post-processing of the
voltage files.

For parallel simulators, if gather is True, all data will be gathered
to the master node and a single output file created there. Otherwise, a
file will be written on each node, containing only the cells simulated
on that node.


**randomInit(self, rand_distr)**

Set initial membrane potentials for all the cells in the population to
random values.


**record(self, record_from=None, rng=None, to_file=True)**

If record_from is not given, record spikes from all cells in the Population.
record_from can be an integer - the number of cells to record from, chosen
at random (in this case a random number generator can also be supplied)
- or a list containing the ids of the cells to record.


**record_gsyn(self, record_from=None, rng=None, to_file=True)**

If record_from is not given, record synaptic conductances
for all cells in the Population.
record_from can be an integer - the number of cells to record from, chosen
at random (in this case a random number generator can also be supplied)
- or a list containing the ids of the cells to record.


**record_v(self, record_from=None, rng=None, to_file=True)**

If record_from is not given, record the membrane potential for all cells in
the Population.
record_from can be an integer - the number of cells to record from, chosen
at random (in this case a random number generator can also be supplied)
- or a list containing the ids of the cells to record.


**rset(self, parametername, rand_distr)**

'Random' set. Set the value of parametername to a value taken from
rand_distr, which should be a !RandomDistribution object.


**set(self, param, val=None)**

Set one or more parameters for every cell in the population.

param can be a dict, in which case val should not be supplied, or a string
giving the parameter name, in which case val is the parameter value.
val can be a numeric value, or list of such (e.g. for setting spike times).

e.g. p.set("tau_m",20.0).

     p.set({'tau_m':20,'v_rest':-65})


**tset(self, parametername, value_array)**

'Topographic' set. Set the value of parametername to the values in
value_array, which must have the same dimensions as the Population.


----

ID
--

Instead of storing ids as integers, we store them as ID objects,
which allows a syntax like:

    p[3,4].tau_m = 20.0

where p is a Population object.

**__init__(self, n)**

Create an ID object with numerical value `n`.


**__getattr__(self, name)**

Get the value of the cell parameter `name`, in PyNN standard units.



**get_native_parameters(self)**

Return a dictionary of parameters for the native cell model.


**get_parameters(self)**

Return a dict of all cell parameters.


**inject(self, current_source)**

Inject current from a current source object into the cell.


**is_standard_cell(self)**

**set_native_parameters(self, parameters)**

Set parameters of the native cell model from a dictionary.


**set_parameters(self, **parameters)**

Set cell parameters, given as a sequence of parameter=value arguments.


----

Projection
----------

A container for all the connections of a given type (same synapse type and
plasticity mechanisms) between two populations, together with methods to set
parameters of those connections, including of plasticity mechanisms.

**__init__(self, presynaptic_population, postsynaptic_population, method, source=None, target=None, synapse_dynamics=None, label=None, rng=None)**


presynaptic_population and postsynaptic_population - Population objects.

source - string specifying which attribute of the presynaptic cell
         signals action potentials

target - string specifying which synapse on the postsynaptic cell to
         connect to

If source and/or target are not given, default values are used.

method - a Connector object, encapsulating the algorithm to use for
         connecting the neurons.

synapse_dynamics - a `!SynapseDynamics` object specifying which
synaptic plasticity mechanisms to use.

rng - specify an RNG object to be used by the Connector.


**__len__(self)**

Return the total number of local connections.


**describe(self, template='standard')**

Return a human-readable description of the projection


**getDelays(self, format='list', gather=True)**

Get synaptic delays for all connections in this Projection.

Possible formats are: a list of length equal to the number of connections
in the projection, a 2D delay array (with NaN for non-existent
connections).


**getSynapseDynamics(self, parameter_name, format='list', gather=True)**

Get parameters of the dynamic synapses for all connections in this
Projection.


**getWeights(self, format='list', gather=True)**

Get synaptic weights for all connections in this Projection.

Possible formats are: a list of length equal to the number of connections
in the projection, a 2D weight array (with NaN for non-existent
connections). Note that for the array format, if there is more than
one connection between two cells, the summed weight will be given.


**printWeights(self, filename, format='list', gather=True)**

Print synaptic weights to file. In the array format, zeros are printed for non-existent connections.


**randomizeDelays(self, rand_distr)**

Set delays to random values taken from rand_distr.


**randomizeSynapseDynamics(self, param, rand_distr)**

Set parameters of the synapse dynamics to values taken from rand_distr


**randomizeWeights(self, rand_distr)**

Set weights to random values taken from rand_distr.


**saveConnections(self, filename, gather=True, compatible_output=True)**

Save connections to file in a format suitable for reading in with a
!FromFileConnector.


**setDelays(self, d)**

d can be a single number, in which case all delays are set to this
value, or a list/1D array of length equal to the number of connections
in the projection, or a 2D array with the same dimensions as the
connectivity matrix (as returned by `getDelays(format='array')`).


**setSynapseDynamics(self, param, value)**

Set parameters of the dynamic synapses for all connections in this
projection.


**setWeights(self, w)**

w can be a single number, in which case all weights are set to this
value, or a list/1D array of length equal to the number of connections
in the projection, or a 2D array with the same dimensions as the
connectivity matrix (as returned by `getWeights(format='array')`).
Weights should be in nA for current-based and ÂµS for conductance-based
synapses.


**size(self, gather=True)**

Return the total number of connections.
    - only local connections, if gather is False,
    - all connections, if gather is True (default)


**weightHistogram(self, min=None, max=None, nbins=10)**

Return a histogram of synaptic weights.
If min and max are not given, the minimum and maximum weights are
calculated automatically.


----


AllToAllConnector
-----------------

Connects all cells in the presynaptic population to all cells in the
postsynaptic population.

**__init__(self, allow_self_connections=True, weights=0.0, delays=None, space=<pyNN.common.Space object at 0x34f3790>)**

Create a new connector.

`allow_self_connections` -- if the connector is used to connect a
    Population to itself, this flag determines whether a neuron is
    allowed to connect to itself, or only to other neurons in the
    Population.

`weights` -- may either be a float, a !RandomDistribution object, a list/
             1D array with at least as many items as connections to be
             created. Units nA.

`delays`  -- as `weights`. If `None`, all synaptic delays will be set
             to the global minimum delay.


----


OneToOneConnector
-----------------

Where the pre- and postsynaptic populations have the same size, connect
cell i in the presynaptic population to cell i in the postsynaptic
population for all i.

**__init__(self, weights=0.0, delays=None)**

Create a new connector.

`weights` -- may either be a float, a !RandomDistribution object, a list/
             1D array with at least as many items as connections to be
             created. Units nA.

`delays`  -- as `weights`. If `None`, all synaptic delays will be set
             to the global minimum delay.

----


FixedProbabilityConnector
-------------------------

For each pair of pre-post cells, the connection probability is constant.

**__init__(self, p_connect, allow_self_connections=True, weights=0.0, delays=None, space=<pyNN.common.Space object at 0x34f3890>)**

Create a new connector.

`p_connect` -- a float between zero and one. Each potential connection
               is created with this probability.

`allow_self_connections` -- if the connector is used to connect a
    Population to itself, this flag determines whether a neuron is
    allowed to connect to itself, or only to other neurons in the
    Population.

`weights` -- may either be a float, a !RandomDistribution object, a list/
             1D array with at least as many items as connections to be
             created. Units nA.

`delays`  -- as `weights`. If `None`, all synaptic delays will be set
             to the global minimum delay.


----


DistanceDependentProbabilityConnector
-------------------------------------

For each pair of pre-post cells, the connection probability depends on distance.

**__init__(self, d_expression, allow_self_connections=True, weights=0.0, delays=None, space=<pyNN.common.Space object at 0x34f38f0>)**

Create a new connector.

`d_expression` -- the right-hand side of a valid python expression for
    probability, involving 'd', e.g. "exp(-abs(d))", or "d<3"
`space` -- a Space object.

`weights` -- may either be a float, a !RandomDistribution object, a list/
             1D array with at least as many items as connections to be
             created, or a !DistanceDependence object. Units nA.

`delays`  -- as `weights`. If `None`, all synaptic delays will be set
             to the global minimum delay.


----


FixedNumberPreConnector
-----------------------

Each post-synaptic neuron is connected to exactly n pre-synaptic neurons
chosen at random.

If n is less than the size of the pre-synaptic population, there are no
multiple connections, i.e., no instances of the same pair of neurons being
multiply connected. If n is greater than the size of the pre-synaptic
population, all possible single connections are made before starting to add
duplicate connections.

**__init__(self, n, allow_self_connections=True, weights=0.0, delays=None)**

Create a new connector.

`n` -- either a positive integer, or a `!RandomDistribution` that produces
       positive integers. If `n` is a `!RandomDistribution`, then the
       number of pre-synaptic neurons is drawn from this distribution
       for each post-synaptic neuron.

`allow_self_connections` -- if the connector is used to connect a
    Population to itself, this flag determines whether a neuron is
    allowed to connect to itself, or only to other neurons in the
    Population.

`weights` -- may either be a float, a !RandomDistribution object, a list/
             1D array with at least as many items as connections to be
             created. Units nA.

`delays`  -- as `weights`. If `None`, all synaptic delays will be set
             to the global minimum delay.


----


FixedNumberPostConnector
------------------------

Each pre-synaptic neuron is connected to exactly n post-synaptic neurons
chosen at random.

If n is less than the size of the post-synaptic population, there are no
multiple connections, i.e., no instances of the same pair of neurons being
multiply connected. If n is greater than the size of the post-synaptic
population, all possible single connections are made before starting to add
duplicate connections.

**__init__(self, n, allow_self_connections=True, weights=0.0, delays=None)**

Create a new connector.

`n` -- either a positive integer, or a `!RandomDistribution` that produces
       positive integers. If `n` is a `!RandomDistribution`, then the
       number of post-synaptic neurons is drawn from this distribution
       for each pre-synaptic neuron.

`allow_self_connections` -- if the connector is used to connect a
       Population to itself, this flag determines whether a neuron is
       allowed to connect to itself, or only to other neurons in the
       Population.

`weights` -- may either be a float, a !RandomDistribution object, a list/
             1D array with at least as many items as connections to be
             created. Units nA.

`delays`  -- as `weights`. If `None`, all synaptic delays will be set
             to the global minimum delay.


----


FromListConnector
-----------------

Make connections according to a list.

**__init__(self, conn_list)**

Create a new connector.

`conn_list` -- a list of tuples, one tuple for each connection. Each
               tuple should contain:
                  (pre_addr, post_addr, weight, delay)
               where pre_addr is the address (a tuple) of the presynaptic
               neuron, and post_addr is the address of the postsynaptic
               neuron.


----


FromFileConnector
-----------------

Make connections according to a list read from a file.

**__init__(self, filename, distributed=False)**

Create a new connector.

`filename` -- name of a text file containing a list of connections, in
              the format required by `!FromListConnector`.

`distributed` -- if this is True, then each node will read connections
                 from a file called `filename.x`, where `x` is the MPI
                 rank. This speeds up loading connections for
                 distributed simulations.


----



----
Standard neuron models
======================

----

IF_curr_exp
-----------

Leaky integrate and fire model with fixed threshold and
decaying-exponential post-synaptic current. (Separate synaptic currents for
excitatory and inhibitory synapses.

**__init__(self, parameters)**


**default_parameters** = {

=============   ==========
=============   ==========
'tau_refrac':   0.0 
'tau_m':        20.0 
'i_offset':     0.0 
'cm':           1.0 
'v_init':       -65.0 
'v_thresh':     -50.0
'tau_syn_E':    5.0 
'v_rest':       -65.0 
'tau_syn_I':    5.0 
'v_reset':      -65.0 
=============   ==========

}

----


IF_curr_alpha 
-------------

Leaky integrate and fire model with fixed threshold and alpha-function-
shaped post-synaptic current.

**__init__(self, parameters)**


**default_parameters** = {

=============   ==========
=============   ==========
'tau_refrac':   0.0 
'tau_m':        20.0 
'i_offset':     0.0 
'cm':           1.0 
'v_init':       -65.0 
'v_thresh':     -50.0 
'tau_syn_E':    0.5 
'v_rest':       -65.0 
'tau_syn_I':    0.5 
'v_reset':      -65.0 
=============   ==========

}

----


IF_cond_exp
-----------

Leaky integrate and fire model with fixed threshold and
exponentially-decaying post-synaptic conductance.

**__init__(self, parameters)**


**default_parameters** = {

=============   ==========
=============   ==========
'tau_refrac':   0.0 
'tau_m':        20.0 
'e_rev_E':      0.0 
'i_offset':     0.0 
'cm':           1.0 
'e_rev_I':      -70.0 
'v_init':       -65.0 
'v_thresh':     -50.0 
'tau_syn_E':    5.0 
'v_rest':       -65.0 
'tau_syn_I':    5.0 
'v_reset':      -65.0 
=============   ==========

}

----


IF_cond_alpha
-------------

Leaky integrate and fire model with fixed threshold and alpha-function-
shaped post-synaptic conductance.

**__init__(self, parameters)**


**default_parameters** = {

=============   ==========
=============   ==========
'tau_refrac':   0.0 
'tau_m':        20.0 
'e_rev_E':      0.0 
'i_offset':     0.0 
'cm':           1.0 
'e_rev_I':      -70.0 
'v_init':       -65.0 
'v_thresh':     -50.0 
'tau_syn_E':    0.3 
'v_rest':       -65.0 
'tau_syn_I':    0.5 
'v_reset':      -65.0 
=============   ==========

}

----


EIF_cond_alpha_isfa_ista
------------------------

Exponential integrate and fire neuron with spike triggered and sub-threshold
adaptation currents (isfa, ista reps.) according to:

Brette R and Gerstner W (2005) Adaptive Exponential Integrate-and-Fire Model as
an Effective Description of Neuronal Activity. J Neurophysiol 94:3637-3642
See also: IF_cond_exp_gsfa_grr

**__init__(self, parameters)**


**default_parameters** = {

=============   ==========
=============   ==========
'tau_refrac':   0.0 
'a':            4.0 
'tau_m':        9.3667 
'e_rev_E':      0.0 
'i_offset':     0.0 
'cm':           0.281 
'delta_T':      2.0 
'v_init':       -70.6 
'v_thresh':     -50.4 
'b':            0.0805 
'tau_syn_E':    5.0 
'v_reset':      -70.6 
'v_spike':      -40.0 
'e_rev_I':      -80.0 
'tau_syn_I':    5.0 
'tau_w':        144.0 
'w_init':       0.0 
'v_rest':       -70.6 
=============   ==========

}

----


IF_facets_hardware1
-------------------

Leaky integrate and fire model with conductance-based synapses and fixed
threshold as it is resembled by the FACETS Hardware Stage 1. For further
details regarding the hardware model see the FACETS-internal Wiki:
https://facets.kip.uni-heidelberg.de/private/wiki/index.php/WP7_NNM

**__init__(self, parameters)**


**default_parameters** = {

=============   ==========
=============   ==========
'g_leak':       40.0 
'e_rev_I':      -80.0 
'v_thresh':     -55.0 
'tau_syn_E':    30.0 
'v_rest':       -65.0 
'tau_syn_I':    30.0 
'v_reset':      -80.0 
=============   ==========

}

----


HH_cond_exp
-----------

Single-compartment Hodgkin-Huxley model.

**__init__(self, parameters)**


**default_parameters** = {

=============   ==========
=============   ==========
'gbar_K':       6000.0 
'e_rev_E':      0.0 
'gbar_Na':      20000.0 
'cm':           0.2 
'e_rev_leak':   -65.0 
'e_rev_I':      -80.0 
'e_rev_K':      -90.0 
'v_init':       -65.0 
'e_rev_Na':     50.0 
'tau_syn_E':    0.2 
'tau_syn_I':    2.0 
'v_offset':     -63.0 
'i_offset':     0.0 
'g_leak':       10.0 
=============   ==========

}

----


SpikeSourcePoisson
------------------

Spike source, generating spikes according to a Poisson process.

**__init__(self, parameters)**


**default_parameters** = {

=============   ==========
=============   ==========
'duration':     1000000.0 
'start':        0.0 
'rate':         1.0 
=============   ==========

}

----


SpikeSourceArray
----------------

Spike source generating spikes at the times given in the spike_times array.

**__init__(self, parameters)**


**default_parameters** = {

===============   ==========
===============   ==========
'spike_times':    [] 
===============   ==========

}

----



----

Specification of synaptic plasticity
====================================

----

SynapseDynamics
---------------

For specifying synapse short-term (faciliation, depression) and long-term
(STDP) plasticity. To be passed as the `synapse_dynamics` argument to
`Projection.!__init!__()` or `connect()`.

**__init__(self, fast=None, slow=None)**

Create a new specification for a dynamic synapse, combining a `fast`
component (short-term facilitation/depression) and a `slow` component
(long-term potentiation/depression).


**describe(self, template='standard')**

Return a human-readable description of the synaptic properties.


----


STDPMechanism
-------------

Specification of STDP models.

**__init__(self, timing_dependence=None, weight_dependence=None, voltage_dependence=None, dendritic_delay_fraction=1.0)**

**describe(self)**

Return a human-readable description of the STDP mechanism.


----


TsodyksMarkramMechanism
-----------------------

**__init__(self, U=0.5, tau_rec=100.0, tau_facil=0.0, u0=0.0, x0=1.0, y0=0.0)**

----


AdditiveWeightDependence
------------------------

The amplitude of the weight change is fixed for depression (`A_minus`)
and for potentiation (`A_plus`).
If the new weight would be less than `w_min` it is set to `w_min`. If it would
be greater than `w_max` it is set to `w_max`.

**__init__(self, w_min=0.0, w_max=1.0, A_plus=0.01, A_minus=0.01)**

----


MultiplicativeWeightDependence
------------------------------

The amplitude of the weight change depends on the current weight.
For depression, Dw propto w-w_min
For potentiation, Dw propto w_max-w

**__init__(self, w_min=0.0, w_max=1.0, A_plus=0.01, A_minus=0.01)**

----


AdditivePotentiationMultiplicativeDepression
--------------------------------------------

The amplitude of the weight change depends on the current weight for
depression (Dw propto w-w_min) and is fixed for potentiation.

**__init__(self, w_min=0.0, w_max=1.0, A_plus=0.01, A_minus=0.01)**

----


GutigWeightDependence
---------------------

The amplitude of the weight change depends on the current weight.
For depression, Dw propto w-w_min
For potentiation, Dw propto w_max-w

**__init__(self, w_min=0.0, w_max=1.0, A_plus=0.01, A_minus=0.01, mu_plus=0.5, mu_minus=0.5)**

----


SpikePairRule
-------------

**__init__(self, tau_plus=20.0, tau_minus=20.0)**

----



----

Current injection
=================


----

DCSource
--------

Source producing a single pulse of current of constant amplitude.

**__init__(self, amplitude=1.0, start=0.0, stop=None)**

Construct the current source.

        Arguments:

            start     -- onset time of pulse in ms

            stop      -- end of pulse in ms

            amplitude -- pulse amplitude in nA


**inject_into(self, cell_list)**

Inject this current source into some cells.


----


StepCurrentSource
-----------------

A step-wise time-varying current source.

**__init__(self, times, amplitudes)**

Construct the current source.

        Arguments:

            times      -- list/array of times at which the injected current changes.

            amplitudes -- list/array of current amplitudes to be injected at the
                          times specified in `times`.

        The injected current will be zero up until the first time in `times`. The
        current will continue at the final value in `amplitudes` until the end
        of the simulation.


**inject_into(self, cell_list)**

Inject this current source into some cells.


----


ACSource
--------

Source producing a single pulse of current of constant amplitude.

**__init__(self, amplitude=1.0, offset=0.0, frequency=10, phase=0.0, start=0.0, stop=None)**

Construct the current source.

        Arguments:

            start     -- onset time of pulse in ms

            stop      -- end of pulse in ms

            amplitude -- pulse amplitude in nA

            sine_amp  -- sine amplitude in nA

            frequency -- frequency in Hz

            phase     -- phase in degree


**inject_into(self, cell_list)**

Inject this current source into some cells.


----


NoisyCurrentSource
------------------

A Gaussian "white" noise current source. The current amplitude changes at fixed
    intervals, with the new value drawn from a Gaussian distribution.

**__init__(self, mean, stdev, dt=None, start=0.0, stop=None, rng=None)**

Construct the current source.

        Required arguments:

            mean  -- mean current amplitude in nA

            stdev -- standard deviation of the current amplitude in nA

        Optional arguments:

            dt    -- interval between updates of the current amplitude. Must be
                     a multiple of the simulation time step. If not specified,
                     the simulation time step will be used.

            start -- onset of the current injection in ms. If not specified, the
                     current will begin at the start of the simulation.

            stop  -- end of the current injection in ms. If not specified, the
                     current will continue until the end of the simulation.

            rng   -- an RNG object from the `pyNN.random` module. For speed,
                     this should be a `NativeRNG` instance (uses the simulator's
                     internal random number generator). For reproducibility
                     across simulators, use one of the other RNG types. If not
                     specified, a NumpyRNG is used.


**inject_into(self, cell_list)**

Inject this current source into some cells.


----



----

File formats
============


----

BaseFile
--------

Base class for PyNN File classes.

**__del__(self)**

**__init__(self, filename, mode='r')**

Open a file with the given filename and mode.


**close(self)**

Close the file.


**get_metadata(self)**

Read metadata from the file and return a dict.


**read(self)**

Read data from the file and return a !NumPy array.


**write(self, data, metadata)**

Write data and metadata to file. `data` should be a !NumPy array,
`metadata` should be a dictionary.


----


StandardTextFile
----------------

Data and metadata is written as text. Metadata is written at the top of the
file, with each line preceded by "#". Data is written with one data point per line.

----


PickleFile
----------

Data and metadata are pickled and saved to file.

----


NumpyBinaryFile
---------------

Data and metadata are saved in .npz format, which is a zipped archive of
arrays.

----


HDF5ArrayFile
-------------

Data are saved as an array within a node named "data". Metadata are
saved as attributes of this node.

----



----

Exceptions
==========

----

InvalidParameterValueError
---------------------------

Inappropriate parameter value

----


NonExistentParameterError
-------------------------

Model parameter does not exist.

----


InvalidDimensionsError
----------------------

Argument has inappropriate shape/dimensions.

----


ConnectionError
---------------

Attempt to create an invalid connection or access a non-existent connection.

----


InvalidModelError
-----------------

Attempt to use a non-existent model type.

----


RoundingWarning
---------------

The argument has been rounded to a lower level of precision by the simulator.

----


NothingToWriteError
-------------------

There is no data available to write.

----


InvalidWeightError
------------------

Invalid value for the synaptic weight.

----


NotLocalError
-------------

Attempt to access a cell or connection that does not exist on this node (but exists elsewhere).

----


RecordingError
--------------

Attempt to record a variable that does not exist for this cell type.

----



----

The random module
=================

----

NumpyRNG
--------

Wrapper for the numpy.random.!RandomState class (Mersenne Twister PRNG).

**__getattr__(self, name)**

This is to give the PyNN RNGs the same methods as the wrapped RNGs (
numpy.random.!RandomState or the GSL RNGs.


**__init__(self, seed=None, rank=0, num_processes=1, parallel_safe=True)**

**describe(self)**

**next(self, n=1, distribution='uniform', parameters=[], mask_local=None)**

Return n random numbers from the distribution.

        If n >= 0, return a numpy array,
        if n < 0, raise an Exception.


----


GSLRNG
------

Wrapper for the GSL random number generators.

**__getattr__(self, name)**

This is to give GSLRNG the same methods as the GSL RNGs.


**__init__(self, seed=None, type='mt19937', rank=0, num_processes=1, parallel_safe=True)**

**next(self, n=1, distribution='uniform', parameters=[], mask_local=None)**

Return n random numbers from the distribution.

        If n >= 0, return a numpy array,
        if n < 0, raise an Exception.


----


NativeRNG
---------

Signals that the simulator's own native RNG should be used.
Each simulator module should implement a class of the same name which
inherits from this and which sets the seed appropriately.

**__init__(self, seed=None)**

**next(self, n=1, distribution='uniform', parameters=[])**

Return n random numbers from the distribution.

        If n is 1, return a float, if n > 1, return a Numpy array,
        if n <= 0, raise an Exception.


----


RandomDistribution
------------------

Class which defines a next(n) method which returns an array of n random
numbers from a given distribution.

**__init__(self, distribution='uniform', parameters=[], rng=None, boundaries=None, constrain='clip')**

If present, rng should be a NumpyRNG or GSLRNG object.
distribution should be the name of a method supported by the underlying
    random number generator object.

parameters should be a list or tuple containing the arguments expected
    by the underlying method in the correct order. named arguments are
    not yet supported.

boundaries is a tuple (min, max) used to specify explicitly, for distribution
    like Gaussian, Gamma or others, hard boundaries for the parameters. If
    parameters are drawn outside those boundaries, the policy applied will depend
    on the constrain parameter.

constrain control the policy for weights out of the specified boundaries.
    If "clip", random numbers are clipped to the boundaries.
    If "redraw", random numbers are drawn till they fall within the boundaries.

Note that NumpyRNG and GSLRNG distributions may not have the same names,
    e.g., 'normal' for NumpyRNG and 'gaussian' for GSLRNG, and the
    arguments may also differ.


**next(self, n=1, mask_local=None)**

Return n random numbers from the distribution.


----



----

The utility module
==================

colour(col, text)
-----------------


notify(msg='Simulation finished.', subject='Simulation finished.', smtphost=None, address=None)
-----------------------------------------------------------------------------------------------

Send an e-mail stating that the simulation has finished.



get_script_args(n_args, usage='')
---------------------------------

Get command line arguments.

This works by finding the name of the main script and assuming any
arguments after this in sys.argv are arguments to the script.
It would be nicer to use optparse, but this doesn't seem to work too well
with nrniv or mpirun.



init_logging(logfile, debug=False, num_processes=1, rank=0)
-----------------------------------------------------------

----

Timer
-----

For timing script execution.

**time_in_words(s)**

Formats a time in seconds as a string containing the time in days,
        hours, minutes, seconds. Examples::

            >>> time_in_words(1)
            1 second
            >>> time_in_words(123)
            2 minutes, 3 seconds
            >>> time_in_words(24*3600)
            1 day


**__init__(self)**

**diff(self, format=None)**

Return the time since the last time elapsedTime() or diff() was called.


**elapsedTime(self, format=None)**

Return the elapsed time in seconds but keep the clock running.


**reset(self)**

Reset the time to zero, and start the clock.


**start(self)**

Start timing.

----
